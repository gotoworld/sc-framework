ehcache是一个用Java实现的使用简单，高速，实现线程安全的缓存管理类库，ehcache提供了用内存，磁盘文件存储，以及分布式存储方式等多种灵活的cache管理方案。同时ehcache作为开放源代码项目，采用限制比较宽松的Apache License V2.0作为授权方式，被广泛地用于Hibernate,  Spring，Cocoon等其他开源系统。
Ehcache的类层次模型主要为三层，最上层的是CacheManager，他是操作Ehcache的入口。我们可以通过CacheManager.getInstance()获得一个单个的CacheManager，或者通过CacheManager的构造函数创建一个新的CacheManager。每个CacheManager都管理着多个Cache。而每个Cache都以一种类Hash的方式，关联着多个Elemenat。而Element则是我们用于存放要缓存内容的地方。
ehcache的刷新策略
ehcache的刷新策略是当缓存在放入的时候记录一个放入时间，它是用Lazy Evict的方式，在取的时候同设置的TTL比较
ehcache缓存的3种清空策略：
1 FIFO，先进先出
2 LFU，最少被使用，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
3 LRU，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
事件处理
可以为CacheManager添加事件监听，当对CacheManager增删Cache时，事件处理器将会得到通知。要配置事件处理，需要通过ehcache的配置文件来完成。
可以为Cache添加事件监听，当对Cache增删Element时，事件处理器将会得到通知。要配置事件处理，需要通过ehcache的配置文件来完成。
ehcache参数配置：
maxInMemory - 设定内存中创建对象的最大值。
eternal - 设置元素（译注：内存中对象）是否永久驻留。如果是，将忽略超时限制且元素永不消亡。
timeToIdleSeconds - 设置某个元素消亡前的停顿时间。也就是在一个元素消亡之前，两次访问时间的最大时间间隔值。这只能在元素不是永久驻留时有效（译注：如果对象永恒不灭，则设置该属性也无用）。
如果该值是 0 就意味着元素可以停顿无穷长的时间。
timeToLiveSeconds - 为元素设置消亡前的生存时间。也就是一个元素从构建到消亡的最大时间间隔值。这只能在元素不是永久驻留时有效。
overflowToDisk  - 设置当内存中缓存达到maxInMemory 限制时元素是否可写到磁盘上。
 
 
1.       ehcache使用了LinkedHashMap来存放Element。jdk要1.5以上。Ehcache1.5可以使用jdk1.4
如果在添加Elemtent时，缓存中的Element个数达到了最大缓存数并且overflowToDisk配置的属性为true，Ehcache会更具配置项MemoryStoreEvictionPolicy的失效策略将Element输出到磁盘。如果overflowToDisk为fasle，Ehcache将删除内存中Element
值得注意的是缓存中失效的Element并不会别马上清理掉，所以想得到内存的真实大小应该调用方法calculateInMemorySize()方法。
一个ehcache.xml对应一个CacheManager
不同的缓存应该对应不同的硬盘上的路径，否则会报错
注意要想使用磁盘缓存，缓存的Element必须实现序列化接口。否则会抛出NotSerializableException异常。
Ehcache会将每个缓存配置的文件路径下创建一个cache_name.data文件，如果使用的磁盘持久化技术，还会生成一个cache name.index文件。
8.       Ehcache有一个后台线程专门做Ellment失效监测以及清除工作。设置线程运行间隔时间，可通过设置diskExpiryThreadIntervalSeconds属性来完成，此值不宜设置过低，否则会导致清理线程占用大量CPU资源。默认值是120秒。
9.       持久化可在Element的diskPersistent配置项中配置，如果配置为“false”或是“omitted”在CacheManager shutdown或是startup后，用来缓存Element的文件将被清除掉。如果设置为“true”，data和index文件会被保存下来，对于新创建的CacheManager Element也是可用的。
使用时必须显示调用cache. Flush()才会将数据缓存到磁盘中。
磁盘缓存步骤：从MemoryStore中把没有失效的Element刷新到DiskStore，Element被写入到data文件，Element将被序列化到index文件。
12.   磁盘缓存大小默认是没有限制的，不过可通过maxElementsOnDisk来指定。当磁盘缓存达到maxElementsOnDisk指定的值时，Ehcache会清理磁盘中的缓存使用默认策略是LFU（使用频率最低）。
13.   在使用完Ehcache后，必须要shutdown缓存。Ehcache中有自己的关闭机制，不过最好在你的代码中显示调用CacheManager.getInstance().shutdown();
14.   Cache:对于getValue()能取到可序列化的值；getObjectValue()取得非序列化的值
15.   cache.getSize();得到缓存中元素的个数；获得当前MemoryStore中的element数量：cache.getMemoryStoreSize();获得当前DiskStore中element数量：cache.getDiskStoreSize();
16.   在使用完Ehcache后，必须要shutdown缓存。Ehcache中有自己的关闭机制，不过最好在你的代码中显示调用CacheManager.getInstance().shutdown();
17.   ehcache-core-1.6—1.7没有任何依赖；ehcache1.7.1依赖SLF4J，以及相应的log的jar包。
18.   CacheManager可以通过单例（factory的静态方法）或者构造函数（constructors）创建。分别叫做single model和instance model。当两种情况都有的时候，系统会采用单例模式，构造器每次都生成单例模式
19.   对于想存储数据到硬盘，或者集群时复制到其他缓存区域的数据，必须可序列化。如果不可序列化，该数据在进行上述操作时会被丢弃，且没有报错，只是在debug级别有日志信息。
20.   读取cache的数据，有以下几种方式：
Cache-aside: 直接操作数据
Cache-as-sor:read-through、write-through和write-behind的结合
Read-through:
Write-through:
Write-behind:
21.   从ehcache2.0开始，以下属性可以在运行时改变：
• timeToLive
• timeToIdle
• maxElementsInMemory
• maxElementsOnDisk
• memory store eviciton policy
• CacheEventListeners can be added and removed dynamically []
   当eternal属性为“true”时，timeToLive和timeToIdle会失效
22.   以下代码演示怎么运行时修改缓存属性
This example shows how to dynamically modify the cache configuration of an already running cache:
Cache cache = manager.getCache("sampleCache");
CacheConfiguration config = cache.getCacheConfiguration();
config.setTimeToIdleSeconds(60);
config.setTimeToLiveSeconds(120);
config.setMaxElementsInMemory(10000);
config.setMaxElementsOnDisk(1000000);
 
Dynamic cache configurations can also be frozen to prevent future changes:
Cache cache = manager.getCache("sampleCache");
cache.disableDynamicFeatures();
23.   2.5之前是通过元素的个数来表示内存或者硬盘的大小；2.5之后，通过字节数来表示。2.5暂时还没有出来。新属性将会是：
The new cache attributes are:
• maxBytesOnHeap
• maxBytesOffHeap (formerly maxMemoryOffHeap)
• maxBytesOnDisk
甚至，还可以指定比例，如：maxBytesOnHeap="20%".
24.   Ehcache可以将一些数据一直放到缓存或者堆栈或者硬盘或者terracotta的L2中。主要是为了满足Hibernate等一些情况下的需求。但是，这样很容易造成内存溢出的错误
25.   当缓存刚启动时，ehcache提供一个机制可以先加载数据：BootstrapCacheLoader
 
class="net.sf.ehcache.distribution.jgroups.JGroupsBootstrapCacheLoaderFactory"
properties="bootstrapAsynchronously=true"/>
 
DiskStoreBootstrapCacheLoaderFactory：从硬盘加载数据到堆栈
 
class="net.sf.ehcache.store.DiskStoreBootstrapCacheLoaderFactory"
properties="bootstrapAsynchronously=true"/>
 
TerracottaBootstrapCacheLoaderFactory：从terracotta的L2中加载数据
 
class="net.sf.ehcache.store.TerracottaStoreBootstrapCacheLoaderFactory"
properties="bootstrapAsynchronously=true"/>
26.   可以配置ehcache在读或者写的时候，做些事情。
CacheConfiguration config = new CacheConfiguration("copyCache", 1000).copyOnRead(true)
Cache copyCache = new Cache(config);
    默认此属性是false。
 
maxElementsInMemory="10"
eternal="false"
timeToIdleSeconds="5"
timeToLiveSeconds="10"
overflowToDisk="false"
copyOnRead="true"
copyOnWrite="true">
com.company.ehcache.MyCopyStrategy"/>
 
27.   每一个cache都有一个copyStrategy，所以，该实现是要求线程安全的
在ehcache启动的时候，可以设置缓存失效。命令行启动的时候如下：
java -Dnet.sf.ehcache.disabled=true
其他特殊的系统属性：
1）java -Dnet.sf.ehcache.use.classic.lru=true
当LRU被选中的时候，更老的LruMemoryStore实现策略将会被真正采用
28.   ehcache.xml必须遵守ehcache.xsd文件中的要求
29.   当无参的构造函数，或者静态构造方法被调用的时候，系统会在最顶层的classpath路径下找名叫ehcache.xml的配置文件，如果查找失败，会以jar包中的ehcache-failsafe.xml文件（里边的缓存配置极其简单）替代。同时，一个警告会提醒用户建立自己的配置文件。
30.   Update checker可以检查是否有最新的ehcache版本。有两个办法可以去掉该功能：
1）通过系统参数：-Dnet.sf.ehcache.skipUpdateCheck=true
2）通过配置文件:
xsi:noNamespaceSchemaLocation="ehcache.xsd"
updateCheck="false" monitoring="autodetect"
dynamicConfig="true">
31.   Ehcache1.6之前只支持ASCII编码，之后，UTF-8也被支持。但UTF-8比ASCII更多落后，所以没必要做专门的转换
32.   每一个Cachemanager应该有自己的独有的ehcache.xml配置文件。因为，当共用时，硬盘缓存路径或者监听端口将会冲突。系统也会发出警告，提醒用户配置专门的配置文件为每一个cachemanager.在分布式系统中，ehcache.xml应该配置成一样的。
33.   Ehcache有3个存储：
1） 内存存储
2） 非堆存储（大内存，企业ehcache才拥有）
3） 硬盘存储（两个版本：开源的和企业级ehcache）
34.   内存存储
其本质是使用java的LinkedHashMap来实现的。多线程安全、内存管理安全、速度快
35.   calculateInMemorySize()可以用来计算当前ehcache内存占用大小。但生产线上不应该使用，因为这个功能效率非常低
36.   同时，ehcache内部有一个低等级的进程，它会判断元素的是否过期。diskExpiryThreadIntervalSeconds属性可以设置该线程执行的间隔时间(默认是120秒，不能太小，以免影响效率).
37.   非堆存储
Terracotta BigMemory是一个新增的功能，它允许系统占用堆以外的内存，速度是硬盘存储的100倍，允许很大的存储空间被创建（350G被测试过）
因为非堆数据是以字节流的形式存储，所以要求Element的key和value都要是可以序列化的。
因为序列化和反序列化的过程，这种存储形式比内存存储慢10倍
38.   硬盘存储
线程安全的
39.   当maxElementsOnDisk被设置的时候，硬盘上的存储达到限制时，LFU算法会被执行用于清除数据，只能是该算法，不可配置
40.   Persistence被设置成false或者omitted，当系统重启时，不会硬盘的数据存储在硬盘上，.data文件将会被删除.相反，.data文件不会被删除，下次重启后Cachemanager还可以使用.data文件。
41.   虚拟机被停止的时候，强烈建议调用Cachemanager.shutdown()方法。
42.   在关闭java虚拟机时，系统执行以下步骤：
Considerations for guidance on how to safely shut the Virtual Machine down.
When a DiskStore is persisted, the following steps take place:
• Any non-expired Elements of the MemoryStore are flushed to the DiskStore
• Elements awaiting spooling are spooled to the data file
• The free list and element list are serialized to the index file
On startup the following steps take place:
• An attempt is made to read the index file. If it does not exist or cannot be read successfully, due to disk corruption, upgrade of ehcache, change in JDK version etc, then the data file is deleted and the DiskStore starts with no Elements in it.
• If the index file is read successfully, the free list and element list are loaded into memory. Once this is done, the index file contents are removed. This way, if there is a dirty shutdown, when restarted, Ehcache will delete the dirt index and data files.
• The DiskStore starts. All data is available.
• The expiry thread starts. It will delete Elements which have expired.
43.   一个示范性地配置：
把一个拥有8G机器内存的存储分配成各种存储。设想有一个7G的数据集，共7M个元素，每个元素1k大小。
我们设置1G的堆存储和7G的非堆存储：
java -Xms1G -Xmx1G -XX:maxDirectMemorySize=7G
对应的配置文件为：
 
maxElementsInMemory=100
overflowToOffHeap="true"(企业)
maxMemoryOffHeap="7G"
... />
44.   对于第二种集群方法，以下服务器被测试过：
• Glassfish V2/V3
• Tomcat 6
• Jetty 6
Tomcat 6通过了所有的继集成测试
支持Weblogic10.3.2，但是SOAP不兼容。
45.   最大的Ehcache单实例在内存中可以缓存20GB，最大的磁盘可以缓存100GB
46.   关于ehcache server的相关命令用法在user guide的178页
47.    
  
缓存属性：
缓存配置。
以下属性是必须的：
name - cache的标识符，在一个CacheManager中必须唯一
maxElementsInMemory - 在内存中缓存的element的最大数目
maxElementsOnDisk - 在磁盘上缓存的element的最大数目
eternal - 设定缓存的elements是否有有效期。如果为true，timeouts属性被忽略
overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上
 
以下属性是可选的：
timeToIdleSeconds - 缓存element在过期前的空闲时间。默认为0，表示可空闲无限时间. (如果指定了这个时间，是否在被hit的前超过了这个时间就会被remove？在内存缓存数目超限之前不会被remove)
timeToLiveSeconds - 缓存element的有效生命期。这个类似于timeouts，默认为0，不过期(是否通常情况下应该大于等于timeToIdleSeconds，小于会如何？idle时间也会减小和这个数值一样)
diskPersistent - 在VM重启的时候是否持久化磁盘缓存，默认是false。
(测试一下true的情况？重载vm的时候会从磁盘进行序列化到对象)
diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒.  (测试一下0的时候会如何)
memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候，移除缓存中element的策略。默认是LRU，可选的有LFU和FIFO可对缓存中的element配置诸如监听器和加载器。Ehcahe内建了一些
*cacheEventListenerFactory - 监听缓存中element的put